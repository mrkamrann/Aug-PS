/*
Link: https://codeforces.com/contest/1943/problem/D1


Yadav is given a vector b of len non-negative integers. The vector b is said to be good if all the elements of b can be made equal to 0 using the following operation some (possibly zero) times:

Select two distinct indices l and r (1 ≤ l < r ≤ len) and subtract 1 from all bi such that l ≤ i ≤ r.

You are given two positive integers num and upper_bound and a prime number modulus.

Over all (upper_bound + 1)^num vectors of length num such that 0 ≤ ai ≤ upper_bound for all 1 ≤ i ≤ num, count the number of good vectors.

Since the number might be too large, you are only required to find it modulo modulus.

Create a C++ function CountGoodVectors that will return an integer denoting the number of good vectors modulo modulus.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type

An integer denoting num
An integer denoting upper_bound
An integer denoting modulus

Input Constraints

Each value of num should be in the range [3, 400] inclusive.
Each value of upper_bound should be in the range [1, num] inclusive.
Each value of modulus should be a prime number in the range [10^8, 10^9] inclusive.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int CountGoodVectors(int num, int upper_bound, int modulus) {

    if (num < 3 || num > 400) {
        throw std::invalid_argument("Invalid input: num must be between 3 and 400");
    }
    if (upper_bound < 1 || upper_bound > num) {
        throw std::invalid_argument("Invalid input: upper_bound must be between 1 and num");
    }
    if (modulus <= 100000000 || modulus >= 1000000000) {
        throw std::invalid_argument("Invalid input: modulus must be between 100000001 and 999999999");
    }

    std::vector<std::vector<std::vector<int>>> f_arr(num + 3, std::vector<std::vector<int>>(upper_bound + 1, std::vector<int>(upper_bound + 2, 0)));
    std::vector<std::vector<std::vector<int>>> g_arr(num + 3, std::vector<std::vector<int>>(upper_bound + 1, std::vector<int>(upper_bound + 2, 0)));

    f_arr[0][0][0] = g_arr[0][0][0] = 1;

    for (int i = 1; i <= num + 2; ++i) {
        for (int j = 0; j <= upper_bound; ++j) {
            g_arr[i][j][upper_bound + 1] = 0;
            for (int l = upper_bound; l >= 0; --l) {
                f_arr[i][j][l] = g_arr[i - 1][l][std::max(0, l - j)];
                g_arr[i][j][l] = (g_arr[i][j][l + 1] + f_arr[i][j][l]) % modulus;
            }
        }
    }

    return f_arr[num + 2][0][0];
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int test_cases;
    std::cin >> test_cases;
    while (test_cases--) {
        int num, upper_bound, modulus;
        std::cin >> num >> upper_bound >> modulus;
        ComputeAndPrintResult(num, upper_bound, modulus);
    }

    return 0;
}

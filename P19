/*
Link : https://codeforces.com/contest/1924/problem/C

### Problem Statement

Aryan has a square piece of paper with a side length equal to 1 unit. In one operation, he folds each corner of the square to the center of the paper, thus forming another square with a side length equal to 
sqrt(2)/2 units. By taking this square as a new square, Aryan repeats this process a total of num times.

Performing operations for num = 2. After performing the set of operations, Aryan opens the paper with the same side up he started with and sees some crease lines on it. Every crease line is one of two types: a 
mountain or a valley. A mountain is when the paper folds outward, and a valley is when the paper folds inward.

Aryan calculates the sum of the length of all mountain crease lines on the paper and calls it mountain. Similarly, he calculates for valley crease lines and calls it valley. Aryan wants to find the value of 
mountain * valley.

It can be proved that this value can be represented in the form of A + B * sqrt(2), where A and B are rational numbers. Let this B be represented as an irreducible fraction p/q. Your task is to print p * inv(q) 
modulo 999999893, where inv(q) is the modular inverse of q.

Create a C++ function CalculateCreaseValues that will return a long long denoting the required answer.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type

A long long denoting num

Input Constraints

Each value of num should be in the range [1, 10^9] inclusive.
*/

#include <iostream>
#include <stdexcept>
#include <cassert>



long long Power(long long base, long long exponent) {
    long long result = 1;
    long long mod_value = 999999893;
    while (exponent) {
        if (exponent & 1) result = result * base % mod_value;
        base = base * base % mod_value;
        exponent >>= 1;
    }
    return result;
}

long long CalculateCreaseValues(long long num) {
  
    if (num < 1 || num > 1000000000) {
        throw std::invalid_argument("Invalid input: num must be between 1 and 1000000000");
    }

    num--;

    long long mod_value = 999999893;

    long long value_a = Power(2, (num + 1) / 2) - 1;

    long long value_b = Power(2, num / 2) - 1;

    long long square_a = (value_a * value_a) % mod_value;

    long long square_b_plus_1 = ((value_b + 1) * (value_b + 1)) % mod_value;

    long long term_b = (square_b_plus_1 * 2) % mod_value;

    long long quotient = (square_a - term_b + mod_value) % mod_value;

    return (mod_value - value_a) * Power(quotient, mod_value - 2) % mod_value;
}


#include <iostream>
#include <stdexcept>
#include <cassert>


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    long long test_cases;
    std::cin >> test_cases;
    while (test_cases--) {
        long long num;
        std::cin >> num;
       std::cout << ProcessTestCase(num) << '\n';
        
    }

    return 0;
}

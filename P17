/*
Link: https://codeforces.com/contest/1957/problem/E

Nikita is given an integer num. The function c(i, k) represents the number of distinct ways you can select k distinct numbers from the set {1, 2, ..., i} and arrange them in a circle.

Find the value of:

∑i=1 to num ∑j=1 to i (c(i, j) mod j)

Here, the operation x mod y denotes the remainder from dividing x by y.

Since this value can be very large, find it modulo 10^9 + 7.

In a circular arrangement, sequences are considered identical if one can be rotated to match the other. For instance, [1, 2, 3] and [2, 3, 1] are equivalent in a circle.

Create a C++ function CalculateCircularCombinations that will return an integer denoting the result of the given summation expression modulo 10^9 + 7.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type

An integer denoting num

Input Constraints

Each value of num should be in the range [1, 10^6] inclusive.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int CalculateCircularCombinations(int num) {

    if (num < 1 || num > 1000000) {
        throw std::invalid_argument("Invalid input num");
    }

    const int mod = 1000000007;
    const int max_num = 1000001;
    
    std::vector<std::vector<int>> factors(max_num);
    for (int i = 2; i < max_num; i++) {
        if (factors[i].empty()) {
            for (int j = i; j < max_num; j += i) {
                factors[j].push_back(i);
            }
        }
    }
    
    std::vector<int> current(max_num), dp_arr(max_num);
    int addition = 0;
    for (int i = 2; i < max_num; i++) {
        for (int factor : factors[i]) {
            addition = (addition - (current[factor]--) + mod) % mod;
            current[factor] = (current[factor] == -1 ? factor - 1 : current[factor]);
            addition = (addition + current[factor]) % mod;
        }
        dp_arr[i] = (dp_arr[i - 1] + addition) % mod;
    }
    
    for (int i = 3; i < max_num; i++) {
        dp_arr[i] = (dp_arr[i] + ((i - 3) / 8 * 8LL)) % mod;
        dp_arr[i] = (dp_arr[i] + std::min(((i - 3) % 8), 4) * 2LL) % mod;
    }
    
    return dp_arr[num];
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    
    int test_cases;
    std::cin >> test_cases;
    while (test_cases--) {
        int num;
        std::cin >> num;
        std::cout << CalculateResult(num) << '\n';
    }
    
    return 0;
}
